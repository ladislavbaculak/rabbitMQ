import pika


def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)


class Rabbit:
    '''Using routing key in basic publish, using binding key in queue bind
    If delivery mode is 2 message is persistent and if value is any other,
    message is transient.
    '''

    def __init__(self, address, port, routing_key='', queue_name='',
                 exchange_type='', body='', exchange_name='',
                 binding_key=None, delivery_mode=2):
        self.address = address
        self.port = port
        self.routing_key = routing_key
        self.queue_name = queue_name
        self.exchange_type = exchange_type
        self.body = body
        self.exchange_name = exchange_name
        self.binding_key = binding_key
        self.properties = pika.BasicProperties(str(delivery_mode))

    def connection(self):
        '''Creating a connection to the RabbitMQ broker.
        Take host and port.
        '''

        self.c = pika.BlockingConnection(pika.ConnectionParameters(
                 self.address, self.port))
        self.channel = self.c.channel()
        print(f'You are connected to {self.address}.')

    def create_queue(self, durable=False, exclusive=False):
        '''Creating message queue in RabbitMQ.
        If durable is true, messages will not be lost when Broker server drops,
        If exclusive is true queue will be deleted after disconnecting,
        if we declare queue_name='' name will be generated by RabbitMQ.'''

        queue = self.channel.queue_declare(self.queue_name, durable=durable,
                                           exclusive=exclusive)
        self.queue_name_ = queue.method.queue
        print(f'New queue is created: {self.queue_name_}.')

    def producer(self):
        '''Sending a message to RabbitMQ with producer.
        Producing: sending a message. Program that send a
        message is PRODUCER. Producer can only send messages
        to the exchange.
        '''

        self.channel.basic_publish(exchange=self.exchange_name,
                                   routing_key=self.routing_key,
                                   body=self.body, properties=self.properties)
        print(f'''Sending message: {self.body} through: {"Default" if
                  self.exchange_name == "" else self.exchange_name}
                  to the queue: {self.queue_name_}.''')

    def consumer(self, prefetch_count=0, auto_ack=True):
        '''Recieved a message from RabbitMQ with consumer.
        Auto Aknowledgement make sure message was delivered
        and not stuck in queue'''

        self.channel.basic_qos(prefetch_count)
        self.channel.basic_consume(self.queue_name,
                                   on_message_callback=self.callback,
                                   auto_ack=auto_ack)
        self.channel.start_consuming()

    def callback(self, ch, method, properties, body):
        '''This callback is called when a message is received from RabbitMQ
        If auto_ack = False we send manual acknowledgement back to Broker by
        Consumer, that message was recieved.
        '''
        print(f'Recieved message: {body.decode()}.')
        if self.exchange_type == '':
            ch.basic_ack(delivery_tag=method.delivery_tag)

    def exchange_declaring(self):
        '''This method help declaring the type of exchange is use in broker.
        Exchange types Direct, Topic, Headers, Fanout.
        '''
        self.channel.exchange_declare(self.exchange_name, self.exchange_type)

    def binding(self):
        '''We need to tell exchange to send messages to our queue,
        this relationship between queue and exchange is called binding.'''
        self.channel.queue_bind(self.queue_name_,
                                self.exchange_name,
                                self.binding_key)

    def close_connection(self):
        '''Close connection safely and make sure consumer receives the message.
        '''
        self.c.close()
        print(f'Connection closed and flushed buffers.')
